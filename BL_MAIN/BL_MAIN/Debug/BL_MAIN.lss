
BL_MAIN.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000089e  00007000  00007000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000020  00800060  0000789e  00000932  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000111  00800080  00800080  00000952  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000952  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000984  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001a8  00000000  00000000  000009c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000016ff  00000000  00000000  00000b68  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b92  00000000  00000000  00002267  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000e61  00000000  00000000  00002df9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000350  00000000  00000000  00003c5c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000955  00000000  00000000  00003fac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000f57  00000000  00000000  00004901  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000140  00000000  00000000  00005858  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	0c 94 2a 38 	jmp	0x7054	; 0x7054 <__ctors_end>
    7004:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7008:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    700c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7010:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7014:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7018:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    701c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7020:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7024:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7028:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    702c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7030:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7034:	0c 94 fb 3b 	jmp	0x77f6	; 0x77f6 <__vector_13>
    7038:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    703c:	0c 94 24 3c 	jmp	0x7848	; 0x7848 <__vector_15>
    7040:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7044:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7048:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    704c:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>
    7050:	0c 94 47 38 	jmp	0x708e	; 0x708e <__bad_interrupt>

00007054 <__ctors_end>:
    7054:	11 24       	eor	r1, r1
    7056:	1f be       	out	0x3f, r1	; 63
    7058:	cf e5       	ldi	r28, 0x5F	; 95
    705a:	d8 e0       	ldi	r29, 0x08	; 8
    705c:	de bf       	out	0x3e, r29	; 62
    705e:	cd bf       	out	0x3d, r28	; 61

00007060 <__do_copy_data>:
    7060:	10 e0       	ldi	r17, 0x00	; 0
    7062:	a0 e6       	ldi	r26, 0x60	; 96
    7064:	b0 e0       	ldi	r27, 0x00	; 0
    7066:	ee e9       	ldi	r30, 0x9E	; 158
    7068:	f8 e7       	ldi	r31, 0x78	; 120
    706a:	02 c0       	rjmp	.+4      	; 0x7070 <__do_copy_data+0x10>
    706c:	05 90       	lpm	r0, Z+
    706e:	0d 92       	st	X+, r0
    7070:	a0 38       	cpi	r26, 0x80	; 128
    7072:	b1 07       	cpc	r27, r17
    7074:	d9 f7       	brne	.-10     	; 0x706c <__do_copy_data+0xc>

00007076 <__do_clear_bss>:
    7076:	21 e0       	ldi	r18, 0x01	; 1
    7078:	a0 e8       	ldi	r26, 0x80	; 128
    707a:	b0 e0       	ldi	r27, 0x00	; 0
    707c:	01 c0       	rjmp	.+2      	; 0x7080 <.do_clear_bss_start>

0000707e <.do_clear_bss_loop>:
    707e:	1d 92       	st	X+, r1

00007080 <.do_clear_bss_start>:
    7080:	a1 39       	cpi	r26, 0x91	; 145
    7082:	b2 07       	cpc	r27, r18
    7084:	e1 f7       	brne	.-8      	; 0x707e <.do_clear_bss_loop>
    7086:	0e 94 03 3a 	call	0x7406	; 0x7406 <main>
    708a:	0c 94 4d 3c 	jmp	0x789a	; 0x789a <_exit>

0000708e <__bad_interrupt>:
    708e:	0c 94 00 38 	jmp	0x7000	; 0x7000 <__vectors>

00007092 <flashing_vidRxNotification>:
    _____________________________
*/

void flashing_vidRxNotification(u8* pu8Data , u8 u8len)
{
	bIsRequestReceived = TRUE ;
    7092:	21 e0       	ldi	r18, 0x01	; 1
    7094:	20 93 8c 00 	sts	0x008C, r18	; 0x80008c <bIsRequestReceived>
	SID = pu8Data[0]; // the first byte the service ID
    7098:	fc 01       	movw	r30, r24
    709a:	21 91       	ld	r18, Z+
    709c:	20 93 8b 00 	sts	0x008B, r18	; 0x80008b <SID>
	pReqData = &pu8Data[1] ;
    70a0:	f0 93 89 00 	sts	0x0089, r31	; 0x800089 <pReqData+0x1>
    70a4:	e0 93 88 00 	sts	0x0088, r30	; 0x800088 <pReqData>
	ReqLen = u8len ;
    70a8:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <ReqLen>
    70ac:	08 95       	ret

000070ae <UART_RX_Complete>:
	Function Description        : this FNC IS SUMMING THE DATA RECIEVED FORM UART YOU NEED AT FIRST TO TELL ME HOW MANY BYTES WILL BE SENT
    _____________________________
*/

 void UART_RX_Complete(void)
{
    70ae:	cf 93       	push	r28
    70b0:	df 93       	push	r29
	static u8 RxState = IDLE ;
	static u8 bufferIdx = 0 ;

	if(RxState == IDLE)
    70b2:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <RxState.2048>
    70b6:	81 11       	cpse	r24, r1
    70b8:	08 c0       	rjmp	.+16     	; 0x70ca <UART_RX_Complete+0x1c>
	{
		len = UART_ReceiveByteNoBlock(); // refers how many bytes will be sent x10 03 "control session" 2bytes
    70ba:	0e 94 f0 3b 	call	0x77e0	; 0x77e0 <UART_ReceiveByteNoBlock>
    70be:	80 93 90 01 	sts	0x0190, r24	; 0x800190 <len>
		                                 // 0x34 + size of data will be transferred and normally the size is page size
										 //0x36 +actual data
										 //0x37 transfer exit
		RxState = RUNNING ;
    70c2:	81 e0       	ldi	r24, 0x01	; 1
    70c4:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <RxState.2048>
    70c8:	19 c0       	rjmp	.+50     	; 0x70fc <UART_RX_Complete+0x4e>
	}
	else
	{
		RxBuffer[bufferIdx] = UART_ReceiveByteNoBlock();
    70ca:	c0 91 85 00 	lds	r28, 0x0085	; 0x800085 <bufferIdx.2049>
    70ce:	d0 e0       	ldi	r29, 0x00	; 0
    70d0:	0e 94 f0 3b 	call	0x77e0	; 0x77e0 <UART_ReceiveByteNoBlock>
    70d4:	cf 56       	subi	r28, 0x6F	; 111
    70d6:	df 4f       	sbci	r29, 0xFF	; 255
    70d8:	88 83       	st	Y, r24
		bufferIdx ++ ;
    70da:	80 91 85 00 	lds	r24, 0x0085	; 0x800085 <bufferIdx.2049>
    70de:	8f 5f       	subi	r24, 0xFF	; 255
    70e0:	80 93 85 00 	sts	0x0085, r24	; 0x800085 <bufferIdx.2049>
		if(bufferIdx == len)
    70e4:	60 91 90 01 	lds	r22, 0x0190	; 0x800190 <len>
    70e8:	86 13       	cpse	r24, r22
    70ea:	08 c0       	rjmp	.+16     	; 0x70fc <UART_RX_Complete+0x4e>
		{
			/*all data is received */
			bufferIdx = 0 ;
    70ec:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <bufferIdx.2049>
			RxState = IDLE ;
    70f0:	10 92 86 00 	sts	0x0086, r1	; 0x800086 <RxState.2048>

			/*call application callback*/
			flashing_vidRxNotification(RxBuffer ,len) ;
    70f4:	81 e9       	ldi	r24, 0x91	; 145
    70f6:	90 e0       	ldi	r25, 0x00	; 0
    70f8:	0e 94 49 38 	call	0x7092	; 0x7092 <flashing_vidRxNotification>
		}
	}
}
    70fc:	df 91       	pop	r29
    70fe:	cf 91       	pop	r28
    7100:	08 95       	ret

00007102 <boot_program_page>:
	Function Description        : THIS FNC FOR FLASHING THE HEX FILE THAT WAS SENT BY UART TO ECU
    _____________________________
*/

void boot_program_page (u16 page, u8 *buf)
{
    7102:	cf 93       	push	r28
    7104:	df 93       	push	r29
    7106:	db 01       	movw	r26, r22
	u8 sreg;
	u32 address;
	u16 word ;

	// Disable interrupts.
	sreg = SREG;
    7108:	7f b7       	in	r23, 0x3f	; 63
	cli();
    710a:	f8 94       	cli
	address = page * SPM_PAGESIZE ;
    710c:	ec 01       	movw	r28, r24
    710e:	d6 95       	lsr	r29
    7110:	dc 2f       	mov	r29, r28
    7112:	cc 27       	eor	r28, r28
    7114:	d7 95       	ror	r29
    7116:	c7 95       	ror	r28

	boot_page_erase_safe (address);
    7118:	07 b6       	in	r0, 0x37	; 55
    711a:	00 fc       	sbrc	r0, 0
    711c:	fd cf       	rjmp	.-6      	; 0x7118 <boot_program_page+0x16>
    711e:	e1 99       	sbic	0x1c, 1	; 28
    7120:	fe cf       	rjmp	.-4      	; 0x711e <boot_program_page+0x1c>
    7122:	83 e0       	ldi	r24, 0x03	; 3
    7124:	fe 01       	movw	r30, r28
    7126:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    712a:	e8 95       	spm

	for (i=0; i<SPM_PAGESIZE; i+=2)
    712c:	20 e0       	ldi	r18, 0x00	; 0
    712e:	30 e0       	ldi	r19, 0x00	; 0
    7130:	1c c0       	rjmp	.+56     	; 0x716a <boot_program_page+0x68>
	{
		// Set up little Endian word.
		word  = *buf++;
    7132:	6c 91       	ld	r22, X
		word += (*buf++) << 8;
    7134:	ad 01       	movw	r20, r26
    7136:	4e 5f       	subi	r20, 0xFE	; 254
    7138:	5f 4f       	sbci	r21, 0xFF	; 255
    713a:	11 96       	adiw	r26, 0x01	; 1
    713c:	8c 91       	ld	r24, X
    713e:	90 e0       	ldi	r25, 0x00	; 0
    7140:	98 2f       	mov	r25, r24
    7142:	88 27       	eor	r24, r24
    7144:	86 0f       	add	r24, r22
    7146:	91 1d       	adc	r25, r1

		boot_page_fill_safe(address + i, word);
    7148:	07 b6       	in	r0, 0x37	; 55
    714a:	00 fc       	sbrc	r0, 0
    714c:	fd cf       	rjmp	.-6      	; 0x7148 <boot_program_page+0x46>
    714e:	e1 99       	sbic	0x1c, 1	; 28
    7150:	fe cf       	rjmp	.-4      	; 0x714e <boot_program_page+0x4c>
    7152:	f9 01       	movw	r30, r18
    7154:	ec 0f       	add	r30, r28
    7156:	fd 1f       	adc	r31, r29
    7158:	61 e0       	ldi	r22, 0x01	; 1
    715a:	0c 01       	movw	r0, r24
    715c:	60 93 57 00 	sts	0x0057, r22	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    7160:	e8 95       	spm
    7162:	11 24       	eor	r1, r1
	cli();
	address = page * SPM_PAGESIZE ;

	boot_page_erase_safe (address);

	for (i=0; i<SPM_PAGESIZE; i+=2)
    7164:	2e 5f       	subi	r18, 0xFE	; 254
    7166:	3f 4f       	sbci	r19, 0xFF	; 255
	{
		// Set up little Endian word.
		word  = *buf++;
		word += (*buf++) << 8;
    7168:	da 01       	movw	r26, r20
	cli();
	address = page * SPM_PAGESIZE ;

	boot_page_erase_safe (address);

	for (i=0; i<SPM_PAGESIZE; i+=2)
    716a:	20 38       	cpi	r18, 0x80	; 128
    716c:	31 05       	cpc	r19, r1
    716e:	08 f3       	brcs	.-62     	; 0x7132 <boot_program_page+0x30>
		word += (*buf++) << 8;

		boot_page_fill_safe(address + i, word);
	}

	boot_page_write_safe (address);     // Store buffer in flash page.
    7170:	07 b6       	in	r0, 0x37	; 55
    7172:	00 fc       	sbrc	r0, 0
    7174:	fd cf       	rjmp	.-6      	; 0x7170 <boot_program_page+0x6e>
    7176:	e1 99       	sbic	0x1c, 1	; 28
    7178:	fe cf       	rjmp	.-4      	; 0x7176 <boot_program_page+0x74>
    717a:	85 e0       	ldi	r24, 0x05	; 5
    717c:	fe 01       	movw	r30, r28
    717e:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    7182:	e8 95       	spm

	// Reenable RWW-section again. We need this if we want to jump back
	// to the application after bootloading.

	boot_rww_enable_safe();
    7184:	07 b6       	in	r0, 0x37	; 55
    7186:	00 fc       	sbrc	r0, 0
    7188:	fd cf       	rjmp	.-6      	; 0x7184 <boot_program_page+0x82>
    718a:	e1 99       	sbic	0x1c, 1	; 28
    718c:	fe cf       	rjmp	.-4      	; 0x718a <boot_program_page+0x88>
    718e:	81 e1       	ldi	r24, 0x11	; 17
    7190:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7f8057>
    7194:	e8 95       	spm

	// Re-enable interrupts (if they were ever enabled).

	SREG = sreg;
    7196:	7f bf       	out	0x3f, r23	; 63
}
    7198:	df 91       	pop	r29
    719a:	cf 91       	pop	r28
    719c:	08 95       	ret

0000719e <LOC_vidSendNegResp>:
*/

void LOC_vidSendNegResp(void)
{
	/*TODO : handle NRCs*/
	UART_SendUsingPooling(0x7F) ;
    719e:	8f e7       	ldi	r24, 0x7F	; 127
    71a0:	0e 94 ec 3b 	call	0x77d8	; 0x77d8 <UART_SendUsingPooling>
    71a4:	08 95       	ret

000071a6 <LOC_vidSendPosResp>:
    _____________________________
*/

void LOC_vidSendPosResp(void)
{
	UART_SendUsingPooling(SID + 0x40);
    71a6:	80 91 8b 00 	lds	r24, 0x008B	; 0x80008b <SID>
    71aa:	80 5c       	subi	r24, 0xC0	; 192
    71ac:	0e 94 ec 3b 	call	0x77d8	; 0x77d8 <UART_SendUsingPooling>
    71b0:	08 95       	ret

000071b2 <APP_vidMoveIVT>:
*/

void APP_vidMoveIVT(u8 u8Section)
{
	/*Move IVt to Application [starting from 0]*/
	if(u8Section == APP_SECTION)
    71b2:	81 11       	cpse	r24, r1
    71b4:	0a c0       	rjmp	.+20     	; 0x71ca <APP_vidMoveIVT+0x18>
	{
		/* Enable change of interrupt vectors */
		GICR = (1<<IVCE);
    71b6:	81 e0       	ldi	r24, 0x01	; 1
    71b8:	90 e0       	ldi	r25, 0x00	; 0
    71ba:	9c bf       	out	0x3c, r25	; 60
    71bc:	8b bf       	out	0x3b, r24	; 59
		/* Move interrupts to Application section */
		CLR_BIT(GICR,IVSEL);
    71be:	8b b7       	in	r24, 0x3b	; 59
    71c0:	9c b7       	in	r25, 0x3c	; 60
    71c2:	8d 7f       	andi	r24, 0xFD	; 253
    71c4:	9c bf       	out	0x3c, r25	; 60
    71c6:	8b bf       	out	0x3b, r24	; 59
    71c8:	08 95       	ret

	/*Move IVt to Bootloader [starting after end of app section]*/
	else
	{
		/* Enable change of interrupt vectors */
		GICR = (1<<IVCE);
    71ca:	81 e0       	ldi	r24, 0x01	; 1
    71cc:	90 e0       	ldi	r25, 0x00	; 0
    71ce:	9c bf       	out	0x3c, r25	; 60
    71d0:	8b bf       	out	0x3b, r24	; 59
		/* Move interrupts to boot Flash section */
		GICR = (1<<IVSEL);
    71d2:	82 e0       	ldi	r24, 0x02	; 2
    71d4:	90 e0       	ldi	r25, 0x00	; 0
    71d6:	9c bf       	out	0x3c, r25	; 60
    71d8:	8b bf       	out	0x3b, r24	; 59
    71da:	08 95       	ret

000071dc <LOC_vidCheckFlashCRC>:
/*__________________________________________________________________*/



u8 LOC_vidCheckFlashCRC(u16 u16StartAdd, u16 u16EndAdd, u16 u16CRC)
{
    71dc:	fc 01       	movw	r30, r24
	u16 addr;
	u8  u8Byte;
	u16 CRC16 = 0xFFFF ;
    71de:	2f ef       	ldi	r18, 0xFF	; 255
    71e0:	3f ef       	ldi	r19, 0xFF	; 255

	/* Compute the CRC */
	for(addr = u16StartAdd; addr < u16EndAdd; addr++)
    71e2:	19 c0       	rjmp	.+50     	; 0x7216 <LOC_vidCheckFlashCRC+0x3a>
	{
		u8Byte = pgm_read_byte(addr);
    71e4:	84 91       	lpm	r24, Z
_crc16_update(uint16_t __crc, uint8_t __data)
{
	uint8_t __tmp;
	uint16_t __ret;

	__asm__ __volatile__ (
    71e6:	28 27       	eor	r18, r24
    71e8:	82 2f       	mov	r24, r18
    71ea:	82 95       	swap	r24
    71ec:	82 27       	eor	r24, r18
    71ee:	08 2e       	mov	r0, r24
    71f0:	86 95       	lsr	r24
    71f2:	86 95       	lsr	r24
    71f4:	80 25       	eor	r24, r0
    71f6:	08 2e       	mov	r0, r24
    71f8:	86 95       	lsr	r24
    71fa:	80 25       	eor	r24, r0
    71fc:	87 70       	andi	r24, 0x07	; 7
    71fe:	02 2e       	mov	r0, r18
    7200:	23 2f       	mov	r18, r19
    7202:	86 95       	lsr	r24
    7204:	07 94       	ror	r0
    7206:	87 95       	ror	r24
    7208:	30 2d       	mov	r19, r0
    720a:	28 27       	eor	r18, r24
    720c:	06 94       	lsr	r0
    720e:	87 95       	ror	r24
    7210:	30 25       	eor	r19, r0
    7212:	28 27       	eor	r18, r24
	u16 addr;
	u8  u8Byte;
	u16 CRC16 = 0xFFFF ;

	/* Compute the CRC */
	for(addr = u16StartAdd; addr < u16EndAdd; addr++)
    7214:	31 96       	adiw	r30, 0x01	; 1
    7216:	e6 17       	cp	r30, r22
    7218:	f7 07       	cpc	r31, r23
    721a:	20 f3       	brcs	.-56     	; 0x71e4 <LOC_vidCheckFlashCRC+0x8>
		u8Byte = pgm_read_byte(addr);
		CRC16 = _crc16_update(CRC16, u8Byte);
	}

	/*Compare calculated CRC with received one*/
	if(u16CRC != CRC16 )
    721c:	24 17       	cp	r18, r20
    721e:	35 07       	cpc	r19, r21
    7220:	11 f0       	breq	.+4      	; 0x7226 <LOC_vidCheckFlashCRC+0x4a>
	{
		return 0; /* Bad CRC */
    7222:	80 e0       	ldi	r24, 0x00	; 0
    7224:	08 95       	ret
	}
	else
	{
		return 1 ; /* Good CRC */
    7226:	81 e0       	ldi	r24, 0x01	; 1
	}
}
    7228:	08 95       	ret

0000722a <flashingMngr_vidMainTask>:
	static u16 u16CodeSize , u16ReceivedLen = 0 ;
	static u8 u8PageNo = 0 ;
	bool_type bValidReq = FALSE, bValidCRC ;
	u16 u16ReceivedCRC ;

	if(bIsRequestReceived)
    722a:	80 91 8c 00 	lds	r24, 0x008C	; 0x80008c <bIsRequestReceived>
    722e:	88 23       	and	r24, r24
    7230:	09 f4       	brne	.+2      	; 0x7234 <flashingMngr_vidMainTask+0xa>
    7232:	df c0       	rjmp	.+446    	; 0x73f2 <flashingMngr_vidMainTask+0x1c8>
	{
		switch(SID)
    7234:	80 91 8b 00 	lds	r24, 0x008B	; 0x80008b <SID>
    7238:	84 33       	cpi	r24, 0x34	; 52
    723a:	41 f1       	breq	.+80     	; 0x728c <flashingMngr_vidMainTask+0x62>
    723c:	30 f4       	brcc	.+12     	; 0x724a <flashingMngr_vidMainTask+0x20>
    723e:	80 31       	cpi	r24, 0x10	; 16
    7240:	59 f0       	breq	.+22     	; 0x7258 <flashingMngr_vidMainTask+0x2e>
    7242:	81 33       	cpi	r24, 0x31	; 49
    7244:	09 f4       	brne	.+2      	; 0x7248 <flashingMngr_vidMainTask+0x1e>
    7246:	95 c0       	rjmp	.+298    	; 0x7372 <flashingMngr_vidMainTask+0x148>
    7248:	ce c0       	rjmp	.+412    	; 0x73e6 <flashingMngr_vidMainTask+0x1bc>
    724a:	86 33       	cpi	r24, 0x36	; 54
    724c:	09 f4       	brne	.+2      	; 0x7250 <flashingMngr_vidMainTask+0x26>
    724e:	4b c0       	rjmp	.+150    	; 0x72e6 <flashingMngr_vidMainTask+0xbc>
    7250:	87 33       	cpi	r24, 0x37	; 55
    7252:	09 f4       	brne	.+2      	; 0x7256 <flashingMngr_vidMainTask+0x2c>
    7254:	7b c0       	rjmp	.+246    	; 0x734c <flashingMngr_vidMainTask+0x122>
    7256:	c7 c0       	rjmp	.+398    	; 0x73e6 <flashingMngr_vidMainTask+0x1bc>
		{
			case SESSION_CONTROL:
			{
				if(pReqData[0] == PROGRAMMING_SESSION && (ReqLen == 2) &&
    7258:	e0 91 88 00 	lds	r30, 0x0088	; 0x800088 <pReqData>
    725c:	f0 91 89 00 	lds	r31, 0x0089	; 0x800089 <pReqData+0x1>
    7260:	80 81       	ld	r24, Z
    7262:	83 30       	cpi	r24, 0x03	; 3
    7264:	71 f4       	brne	.+28     	; 0x7282 <flashingMngr_vidMainTask+0x58>
    7266:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <ReqLen>
    726a:	82 30       	cpi	r24, 0x02	; 2
    726c:	51 f4       	brne	.+20     	; 0x7282 <flashingMngr_vidMainTask+0x58>
				(enuDownloadState ==waiting_ProgrammingSession ))
    726e:	80 91 87 00 	lds	r24, 0x0087	; 0x800087 <enuDownloadState>
	{
		switch(SID)
		{
			case SESSION_CONTROL:
			{
				if(pReqData[0] == PROGRAMMING_SESSION && (ReqLen == 2) &&
    7272:	81 11       	cpse	r24, r1
    7274:	06 c0       	rjmp	.+12     	; 0x7282 <flashingMngr_vidMainTask+0x58>
				(enuDownloadState ==waiting_ProgrammingSession ))
				{
					/*Programming session, Valid request*/
					LOC_vidSendPosResp();
    7276:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <LOC_vidSendPosResp>
					enuDownloadState = waiting_DownloadRequest ;
    727a:	81 e0       	ldi	r24, 0x01	; 1
    727c:	80 93 87 00 	sts	0x0087, r24	; 0x800087 <enuDownloadState>
    7280:	b6 c0       	rjmp	.+364    	; 0x73ee <flashingMngr_vidMainTask+0x1c4>
				}
				else
				{
					/*Invalid request, or sequence error*/
					/*Reset download state*/
					enuDownloadState = waiting_ProgrammingSession ;
    7282:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <enuDownloadState>
					LOC_vidSendNegResp();
    7286:	0e 94 cf 38 	call	0x719e	; 0x719e <LOC_vidSendNegResp>
    728a:	b1 c0       	rjmp	.+354    	; 0x73ee <flashingMngr_vidMainTask+0x1c4>
				}
			}break;

			case DOWNLOAD_REQUEST:
			{
				if((enuDownloadState == waiting_DownloadRequest) &&
    728c:	80 91 87 00 	lds	r24, 0x0087	; 0x800087 <enuDownloadState>
    7290:	81 30       	cpi	r24, 0x01	; 1
    7292:	e1 f4       	brne	.+56     	; 0x72cc <flashingMngr_vidMainTask+0xa2>
				(ReqLen == 3))
    7294:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <ReqLen>
				}
			}break;

			case DOWNLOAD_REQUEST:
			{
				if((enuDownloadState == waiting_DownloadRequest) &&
    7298:	83 30       	cpi	r24, 0x03	; 3
    729a:	d1 f4       	brne	.+52     	; 0x72d0 <flashingMngr_vidMainTask+0xa6>
				(ReqLen == 3))
				{
					/*Valid request*/
					/*Big endian 2 bytes code size*/
					u16CodeSize = pReqData[0]<<8 | pReqData[1] ;
    729c:	e0 91 88 00 	lds	r30, 0x0088	; 0x800088 <pReqData>
    72a0:	f0 91 89 00 	lds	r31, 0x0089	; 0x800089 <pReqData+0x1>
    72a4:	80 81       	ld	r24, Z
    72a6:	90 e0       	ldi	r25, 0x00	; 0
    72a8:	98 2f       	mov	r25, r24
    72aa:	88 27       	eor	r24, r24
    72ac:	21 81       	ldd	r18, Z+1	; 0x01
    72ae:	82 2b       	or	r24, r18
    72b0:	90 93 84 00 	sts	0x0084, r25	; 0x800084 <u16CodeSize.2089+0x1>
    72b4:	80 93 83 00 	sts	0x0083, r24	; 0x800083 <u16CodeSize.2089>
					if(u16CodeSize < MAX_CODE_SIZE)
    72b8:	81 15       	cp	r24, r1
    72ba:	98 43       	sbci	r25, 0x38	; 56
    72bc:	58 f4       	brcc	.+22     	; 0x72d4 <flashingMngr_vidMainTask+0xaa>
					{
						LOC_vidSendPosResp();
    72be:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <LOC_vidSendPosResp>
						enuDownloadState = waiting_TransferData ;
    72c2:	82 e0       	ldi	r24, 0x02	; 2
    72c4:	80 93 87 00 	sts	0x0087, r24	; 0x800087 <enuDownloadState>
						bValidReq = TRUE ;
    72c8:	81 e0       	ldi	r24, 0x01	; 1
    72ca:	05 c0       	rjmp	.+10     	; 0x72d6 <flashingMngr_vidMainTask+0xac>
*/
void flashingMngr_vidMainTask(void)
{
	static u16 u16CodeSize , u16ReceivedLen = 0 ;
	static u8 u8PageNo = 0 ;
	bool_type bValidReq = FALSE, bValidCRC ;
    72cc:	80 e0       	ldi	r24, 0x00	; 0
    72ce:	03 c0       	rjmp	.+6      	; 0x72d6 <flashingMngr_vidMainTask+0xac>
    72d0:	80 e0       	ldi	r24, 0x00	; 0
    72d2:	01 c0       	rjmp	.+2      	; 0x72d6 <flashingMngr_vidMainTask+0xac>
    72d4:	80 e0       	ldi	r24, 0x00	; 0
						LOC_vidSendPosResp();
						enuDownloadState = waiting_TransferData ;
						bValidReq = TRUE ;
					}
				}
				if (bValidReq != TRUE)
    72d6:	81 30       	cpi	r24, 0x01	; 1
    72d8:	09 f4       	brne	.+2      	; 0x72dc <flashingMngr_vidMainTask+0xb2>
    72da:	89 c0       	rjmp	.+274    	; 0x73ee <flashingMngr_vidMainTask+0x1c4>
				{
					/*Invalid request, or sequence error*/
					/*Reset download state*/
					enuDownloadState = waiting_ProgrammingSession ;
    72dc:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <enuDownloadState>
					LOC_vidSendNegResp();
    72e0:	0e 94 cf 38 	call	0x719e	; 0x719e <LOC_vidSendNegResp>
    72e4:	84 c0       	rjmp	.+264    	; 0x73ee <flashingMngr_vidMainTask+0x1c4>
				}
			}break;

			case TRANSFER_DATA:
			{
				if((enuDownloadState ==waiting_TransferData) &&
    72e6:	80 91 87 00 	lds	r24, 0x0087	; 0x800087 <enuDownloadState>
    72ea:	82 30       	cpi	r24, 0x02	; 2
    72ec:	51 f5       	brne	.+84     	; 0x7342 <flashingMngr_vidMainTask+0x118>
				(ReqLen == PAGE_SIZE+1))
    72ee:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <ReqLen>
				}
			}break;

			case TRANSFER_DATA:
			{
				if((enuDownloadState ==waiting_TransferData) &&
    72f2:	81 38       	cpi	r24, 0x81	; 129
    72f4:	31 f5       	brne	.+76     	; 0x7342 <flashingMngr_vidMainTask+0x118>
				(ReqLen == PAGE_SIZE+1))
				{
					/*Write flash page, starting from index 1 [neglect SID] */
					boot_program_page(u8PageNo ,&pReqData[0]);
    72f6:	60 91 88 00 	lds	r22, 0x0088	; 0x800088 <pReqData>
    72fa:	70 91 89 00 	lds	r23, 0x0089	; 0x800089 <pReqData+0x1>
    72fe:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <u8PageNo.2091>
    7302:	90 e0       	ldi	r25, 0x00	; 0
    7304:	0e 94 81 38 	call	0x7102	; 0x7102 <boot_program_page>
					LOC_vidSendPosResp();
    7308:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <LOC_vidSendPosResp>
					u8PageNo ++ ;
    730c:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <u8PageNo.2091>
    7310:	8f 5f       	subi	r24, 0xFF	; 255
    7312:	80 93 82 00 	sts	0x0082, r24	; 0x800082 <u8PageNo.2091>
					u16ReceivedLen += PAGE_SIZE ;
    7316:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__data_end>
    731a:	90 91 81 00 	lds	r25, 0x0081	; 0x800081 <__data_end+0x1>
    731e:	80 58       	subi	r24, 0x80	; 128
    7320:	9f 4f       	sbci	r25, 0xFF	; 255
    7322:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__data_end+0x1>
    7326:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__data_end>
					if(u16ReceivedLen == u16CodeSize)
    732a:	20 91 83 00 	lds	r18, 0x0083	; 0x800083 <u16CodeSize.2089>
    732e:	30 91 84 00 	lds	r19, 0x0084	; 0x800084 <u16CodeSize.2089+0x1>
    7332:	82 17       	cp	r24, r18
    7334:	93 07       	cpc	r25, r19
    7336:	09 f0       	breq	.+2      	; 0x733a <flashingMngr_vidMainTask+0x110>
    7338:	5a c0       	rjmp	.+180    	; 0x73ee <flashingMngr_vidMainTask+0x1c4>
					{
						/*Download is Done*/
						enuDownloadState = waiting_TransferExit;
    733a:	83 e0       	ldi	r24, 0x03	; 3
    733c:	80 93 87 00 	sts	0x0087, r24	; 0x800087 <enuDownloadState>
    7340:	56 c0       	rjmp	.+172    	; 0x73ee <flashingMngr_vidMainTask+0x1c4>
				}
				else
				{
					/*Invalid request, or sequence error*/
					/*Reset download state*/
					enuDownloadState = waiting_ProgrammingSession ;
    7342:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <enuDownloadState>
					LOC_vidSendNegResp();
    7346:	0e 94 cf 38 	call	0x719e	; 0x719e <LOC_vidSendNegResp>
    734a:	51 c0       	rjmp	.+162    	; 0x73ee <flashingMngr_vidMainTask+0x1c4>
					/*TODO: specify NRC*/
				}
			}break;
			case TRANSFER_EXIT:
			{
				if((enuDownloadState == waiting_TransferExit) &&
    734c:	80 91 87 00 	lds	r24, 0x0087	; 0x800087 <enuDownloadState>
    7350:	83 30       	cpi	r24, 0x03	; 3
    7352:	51 f4       	brne	.+20     	; 0x7368 <flashingMngr_vidMainTask+0x13e>
				(ReqLen == 1))
    7354:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <ReqLen>
					/*TODO: specify NRC*/
				}
			}break;
			case TRANSFER_EXIT:
			{
				if((enuDownloadState == waiting_TransferExit) &&
    7358:	81 30       	cpi	r24, 0x01	; 1
    735a:	31 f4       	brne	.+12     	; 0x7368 <flashingMngr_vidMainTask+0x13e>
				(ReqLen == 1))
				{
					LOC_vidSendPosResp();
    735c:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <LOC_vidSendPosResp>
					enuDownloadState = waiting_CheckCRC;
    7360:	84 e0       	ldi	r24, 0x04	; 4
    7362:	80 93 87 00 	sts	0x0087, r24	; 0x800087 <enuDownloadState>
    7366:	43 c0       	rjmp	.+134    	; 0x73ee <flashingMngr_vidMainTask+0x1c4>
				}
				else
				{
					/*Invalid request, or sequence error*/
					/*Reset download state*/
					enuDownloadState = waiting_ProgrammingSession ;
    7368:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <enuDownloadState>
					LOC_vidSendNegResp();
    736c:	0e 94 cf 38 	call	0x719e	; 0x719e <LOC_vidSendNegResp>
    7370:	3e c0       	rjmp	.+124    	; 0x73ee <flashingMngr_vidMainTask+0x1c4>
					/*TODO: specify NRC*/
				}
			}break;
			case CHECK_CRC:
			{
				if((enuDownloadState == waiting_CheckCRC) &&
    7372:	80 91 87 00 	lds	r24, 0x0087	; 0x800087 <enuDownloadState>
    7376:	84 30       	cpi	r24, 0x04	; 4
    7378:	89 f5       	brne	.+98     	; 0x73dc <flashingMngr_vidMainTask+0x1b2>
				(ReqLen == 3))
    737a:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <ReqLen>
					/*TODO: specify NRC*/
				}
			}break;
			case CHECK_CRC:
			{
				if((enuDownloadState == waiting_CheckCRC) &&
    737e:	83 30       	cpi	r24, 0x03	; 3
    7380:	69 f5       	brne	.+90     	; 0x73dc <flashingMngr_vidMainTask+0x1b2>
				(ReqLen == 3))
				{
					u16ReceivedCRC = pReqData[0]<<8 | pReqData[1] ;
    7382:	e0 91 88 00 	lds	r30, 0x0088	; 0x800088 <pReqData>
    7386:	f0 91 89 00 	lds	r31, 0x0089	; 0x800089 <pReqData+0x1>
    738a:	40 81       	ld	r20, Z
    738c:	50 e0       	ldi	r21, 0x00	; 0
    738e:	54 2f       	mov	r21, r20
    7390:	44 27       	eor	r20, r20
    7392:	81 81       	ldd	r24, Z+1	; 0x01
    7394:	48 2b       	or	r20, r24
					/*Validate CRC of flashed code, in range of 0~codeSize*/
					bValidCRC = LOC_vidCheckFlashCRC(0, u16CodeSize, u16ReceivedCRC);
    7396:	60 91 83 00 	lds	r22, 0x0083	; 0x800083 <u16CodeSize.2089>
    739a:	70 91 84 00 	lds	r23, 0x0084	; 0x800084 <u16CodeSize.2089+0x1>
    739e:	80 e0       	ldi	r24, 0x00	; 0
    73a0:	90 e0       	ldi	r25, 0x00	; 0
    73a2:	0e 94 ee 38 	call	0x71dc	; 0x71dc <LOC_vidCheckFlashCRC>
					if(bValidCRC)
    73a6:	88 23       	and	r24, r24
    73a8:	b1 f0       	breq	.+44     	; 0x73d6 <flashingMngr_vidMainTask+0x1ac>
					{
						LOC_vidSendPosResp();
    73aa:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <LOC_vidSendPosResp>
						/*Mark application as Valid*/
						EEPROM_WriteData (VALID_APP_ADDRESS,EEPROM_BYTE_SET);   /////////////////////////////
    73ae:	60 e0       	ldi	r22, 0x00	; 0
    73b0:	80 e0       	ldi	r24, 0x00	; 0
    73b2:	90 e0       	ldi	r25, 0x00	; 0
    73b4:	0e 94 cb 3b 	call	0x7796	; 0x7796 <EEPROM_WriteData>
						#if USE_INTERRUPT ==1
						/*Move vector Table to Application section*/
						APP_vidMoveIVT(APP_SECTION);
    73b8:	80 e0       	ldi	r24, 0x00	; 0
    73ba:	0e 94 d9 38 	call	0x71b2	; 0x71b2 <APP_vidMoveIVT>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    73be:	8f ef       	ldi	r24, 0xFF	; 255
    73c0:	90 e7       	ldi	r25, 0x70	; 112
    73c2:	22 e0       	ldi	r18, 0x02	; 2
    73c4:	81 50       	subi	r24, 0x01	; 1
    73c6:	90 40       	sbci	r25, 0x00	; 0
    73c8:	20 40       	sbci	r18, 0x00	; 0
    73ca:	e1 f7       	brne	.-8      	; 0x73c4 <flashingMngr_vidMainTask+0x19a>
    73cc:	00 c0       	rjmp	.+0      	; 0x73ce <flashingMngr_vidMainTask+0x1a4>
    73ce:	00 00       	nop
						#endif
						_delay_ms(100) ;
						/*start the actual program*/
						asm("jmp 0");
    73d0:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>
    73d4:	05 c0       	rjmp	.+10     	; 0x73e0 <flashingMngr_vidMainTask+0x1b6>
					}
					else
					{
						/*Invalid request, or sequence error*/
						LOC_vidSendNegResp();
    73d6:	0e 94 cf 38 	call	0x719e	; 0x719e <LOC_vidSendNegResp>
    73da:	02 c0       	rjmp	.+4      	; 0x73e0 <flashingMngr_vidMainTask+0x1b6>
					}
				}
				else
				{
					/*Invalid request, or sequence error*/
					LOC_vidSendNegResp();
    73dc:	0e 94 cf 38 	call	0x719e	; 0x719e <LOC_vidSendNegResp>
					/*TODO: specify NRC*/
				}

				enuDownloadState = waiting_ProgrammingSession;
    73e0:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <enuDownloadState>
			}break;
    73e4:	04 c0       	rjmp	.+8      	; 0x73ee <flashingMngr_vidMainTask+0x1c4>
			default:
			{
				/*Unknown SID*/
				/*Invalid request, or sequence error*/
				/*Reset download state*/
				enuDownloadState = waiting_ProgrammingSession ;
    73e6:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <enuDownloadState>
				LOC_vidSendNegResp();
    73ea:	0e 94 cf 38 	call	0x719e	; 0x719e <LOC_vidSendNegResp>
				/*TODO: specify NRC*/
			}
		}
		bIsRequestReceived = FALSE ;
    73ee:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <bIsRequestReceived>
    73f2:	08 95       	ret

000073f4 <flashingMngr_vidHandleReqFromApp>:
}

void flashingMngr_vidHandleReqFromApp(void)
{
	/*Programming session has been sent to Application [Reprogramming request]*/
	SID = 0x10 ;
    73f4:	80 e1       	ldi	r24, 0x10	; 16
    73f6:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <SID>
	LOC_vidSendPosResp();
    73fa:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <LOC_vidSendPosResp>
	enuDownloadState = waiting_DownloadRequest ;
    73fe:	81 e0       	ldi	r24, 0x01	; 1
    7400:	80 93 87 00 	sts	0x0087, r24	; 0x800087 <enuDownloadState>
    7404:	08 95       	ret

00007406 <main>:
#define RED_LED   PINC0
#define GREEN_LED PINC1
#define BLUE_LED  PINC2

int main(void)
{
    7406:	cf 93       	push	r28
    7408:	df 93       	push	r29
    DIO_Init();
    740a:	0e 94 2e 3b 	call	0x765c	; 0x765c <DIO_Init>
	//UART_Init();
	// MOVING THE VEC TABLE
	UART_RX_SetCallBack(UART_RX_Complete);
    740e:	87 e5       	ldi	r24, 0x57	; 87
    7410:	98 e3       	ldi	r25, 0x38	; 56
    7412:	0e 94 f6 3b 	call	0x77ec	; 0x77ec <UART_RX_SetCallBack>
	//UART_RX_InterruptEnable();
	// sei();
	
	u8 validAPP_Val, reqFromApp_Val;
	validAPP_Val = EEPROM_ReadData (VALID_APP_ADDRESS);
    7416:	80 e0       	ldi	r24, 0x00	; 0
    7418:	90 e0       	ldi	r25, 0x00	; 0
    741a:	0e 94 d7 3b 	call	0x77ae	; 0x77ae <EEPROM_ReadData>
    741e:	d8 2f       	mov	r29, r24
	reqFromApp_Val = EEPROM_ReadData (REQ_FROM_APP_ADDRESS);
    7420:	81 e0       	ldi	r24, 0x01	; 1
    7422:	90 e0       	ldi	r25, 0x00	; 0
    7424:	0e 94 d7 3b 	call	0x77ae	; 0x77ae <EEPROM_ReadData>
    7428:	c8 2f       	mov	r28, r24
	
	/******************************************************************/
    if ( (validAPP_Val == EEPROM_BYTE_NOT_SET) | (reqFromApp_Val == EEPROM_BYTE_SET))
    742a:	91 e0       	ldi	r25, 0x01	; 1
    742c:	df 3f       	cpi	r29, 0xFF	; 255
    742e:	09 f0       	breq	.+2      	; 0x7432 <main+0x2c>
    7430:	90 e0       	ldi	r25, 0x00	; 0
    7432:	81 e0       	ldi	r24, 0x01	; 1
    7434:	c1 11       	cpse	r28, r1
    7436:	80 e0       	ldi	r24, 0x00	; 0
    7438:	89 2b       	or	r24, r25
    743a:	01 f1       	breq	.+64     	; 0x747c <main+0x76>
    {
	    /*for debugging*/
	    DIO_WritePin(RED_LED,HIGH);
    743c:	61 e0       	ldi	r22, 0x01	; 1
    743e:	80 e1       	ldi	r24, 0x10	; 16
    7440:	0e 94 3e 3b 	call	0x767c	; 0x767c <DIO_WritePin>
	    DIO_WritePin(BLUE_LED,HIGH);
    7444:	61 e0       	ldi	r22, 0x01	; 1
    7446:	82 e1       	ldi	r24, 0x12	; 18
    7448:	0e 94 3e 3b 	call	0x767c	; 0x767c <DIO_WritePin>
	    UART_Init();
    744c:	0e 94 e0 3b 	call	0x77c0	; 0x77c0 <UART_Init>
	     DIO_WritePin(GREEN_LED,HIGH);
    7450:	61 e0       	ldi	r22, 0x01	; 1
    7452:	81 e1       	ldi	r24, 0x11	; 17
    7454:	0e 94 3e 3b 	call	0x767c	; 0x767c <DIO_WritePin>
	    #if USE_INTERRUPT == 1
	    /*Move Vector Table to boot loader section*/
	    APP_vidMoveIVT(BLD_SECTION);
    7458:	81 e0       	ldi	r24, 0x01	; 1
    745a:	0e 94 d9 38 	call	0x71b2	; 0x71b2 <APP_vidMoveIVT>
		UART_RX_InterruptEnable();
    745e:	0e 94 f2 3b 	call	0x77e4	; 0x77e4 <UART_RX_InterruptEnable>
		sei();
    7462:	78 94       	sei
	    #endif

	    if(reqFromApp_Val == EEPROM_BYTE_SET)
    7464:	c1 11       	cpse	r28, r1
    7466:	07 c0       	rjmp	.+14     	; 0x7476 <main+0x70>
	    {
		    flashingMngr_vidHandleReqFromApp() ;
    7468:	0e 94 fa 39 	call	0x73f4	; 0x73f4 <flashingMngr_vidHandleReqFromApp>
		    /*clr application request*/
		   EEPROM_WriteData(REQ_FROM_APP_ADDRESS, EEPROM_BYTE_NOT_SET);
    746c:	6f ef       	ldi	r22, 0xFF	; 255
    746e:	81 e0       	ldi	r24, 0x01	; 1
    7470:	90 e0       	ldi	r25, 0x00	; 0
    7472:	0e 94 cb 3b 	call	0x7796	; 0x7796 <EEPROM_WriteData>
	    while(1)
	    {
		    #if USE_INTERRUPT == 0
		      UART_RX_Complete();
		    #endif
		    flashingMngr_vidMainTask() ;
    7476:	0e 94 15 39 	call	0x722a	; 0x722a <flashingMngr_vidMainTask>
    747a:	fd cf       	rjmp	.-6      	; 0x7476 <main+0x70>
	    }
    }
    else
    {
	    /*Valid app, jump directly*/
	    asm("jmp 0");
    747c:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>
    }

    return 1 ;
}
    7480:	81 e0       	ldi	r24, 0x01	; 1
    7482:	90 e0       	ldi	r25, 0x00	; 0
    7484:	df 91       	pop	r29
    7486:	cf 91       	pop	r28
    7488:	08 95       	ret

0000748a <DIO_InitPin>:
		case PD:
			return PIND;
			break;
	}
	return 10;
}
    748a:	98 2f       	mov	r25, r24
    748c:	96 95       	lsr	r25
    748e:	96 95       	lsr	r25
    7490:	96 95       	lsr	r25
    7492:	87 70       	andi	r24, 0x07	; 7
    7494:	61 30       	cpi	r22, 0x01	; 1
    7496:	09 f4       	brne	.+2      	; 0x749a <DIO_InitPin+0x10>
    7498:	41 c0       	rjmp	.+130    	; 0x751c <DIO_InitPin+0x92>
    749a:	20 f0       	brcs	.+8      	; 0x74a4 <DIO_InitPin+0x1a>
    749c:	62 30       	cpi	r22, 0x02	; 2
    749e:	09 f4       	brne	.+2      	; 0x74a2 <DIO_InitPin+0x18>
    74a0:	8d c0       	rjmp	.+282    	; 0x75bc <DIO_InitPin+0x132>
    74a2:	08 95       	ret
    74a4:	91 30       	cpi	r25, 0x01	; 1
    74a6:	99 f0       	breq	.+38     	; 0x74ce <DIO_InitPin+0x44>
    74a8:	28 f0       	brcs	.+10     	; 0x74b4 <DIO_InitPin+0x2a>
    74aa:	92 30       	cpi	r25, 0x02	; 2
    74ac:	e9 f0       	breq	.+58     	; 0x74e8 <DIO_InitPin+0x5e>
    74ae:	93 30       	cpi	r25, 0x03	; 3
    74b0:	41 f1       	breq	.+80     	; 0x7502 <DIO_InitPin+0x78>
    74b2:	08 95       	ret
    74b4:	4a b3       	in	r20, 0x1a	; 26
    74b6:	21 e0       	ldi	r18, 0x01	; 1
    74b8:	30 e0       	ldi	r19, 0x00	; 0
    74ba:	b9 01       	movw	r22, r18
    74bc:	02 c0       	rjmp	.+4      	; 0x74c2 <DIO_InitPin+0x38>
    74be:	66 0f       	add	r22, r22
    74c0:	77 1f       	adc	r23, r23
    74c2:	8a 95       	dec	r24
    74c4:	e2 f7       	brpl	.-8      	; 0x74be <DIO_InitPin+0x34>
    74c6:	cb 01       	movw	r24, r22
    74c8:	84 2b       	or	r24, r20
    74ca:	8a bb       	out	0x1a, r24	; 26
    74cc:	08 95       	ret
    74ce:	47 b3       	in	r20, 0x17	; 23
    74d0:	21 e0       	ldi	r18, 0x01	; 1
    74d2:	30 e0       	ldi	r19, 0x00	; 0
    74d4:	b9 01       	movw	r22, r18
    74d6:	02 c0       	rjmp	.+4      	; 0x74dc <DIO_InitPin+0x52>
    74d8:	66 0f       	add	r22, r22
    74da:	77 1f       	adc	r23, r23
    74dc:	8a 95       	dec	r24
    74de:	e2 f7       	brpl	.-8      	; 0x74d8 <DIO_InitPin+0x4e>
    74e0:	cb 01       	movw	r24, r22
    74e2:	84 2b       	or	r24, r20
    74e4:	87 bb       	out	0x17, r24	; 23
    74e6:	08 95       	ret
    74e8:	44 b3       	in	r20, 0x14	; 20
    74ea:	21 e0       	ldi	r18, 0x01	; 1
    74ec:	30 e0       	ldi	r19, 0x00	; 0
    74ee:	b9 01       	movw	r22, r18
    74f0:	02 c0       	rjmp	.+4      	; 0x74f6 <DIO_InitPin+0x6c>
    74f2:	66 0f       	add	r22, r22
    74f4:	77 1f       	adc	r23, r23
    74f6:	8a 95       	dec	r24
    74f8:	e2 f7       	brpl	.-8      	; 0x74f2 <DIO_InitPin+0x68>
    74fa:	cb 01       	movw	r24, r22
    74fc:	84 2b       	or	r24, r20
    74fe:	84 bb       	out	0x14, r24	; 20
    7500:	08 95       	ret
    7502:	41 b3       	in	r20, 0x11	; 17
    7504:	21 e0       	ldi	r18, 0x01	; 1
    7506:	30 e0       	ldi	r19, 0x00	; 0
    7508:	b9 01       	movw	r22, r18
    750a:	02 c0       	rjmp	.+4      	; 0x7510 <DIO_InitPin+0x86>
    750c:	66 0f       	add	r22, r22
    750e:	77 1f       	adc	r23, r23
    7510:	8a 95       	dec	r24
    7512:	e2 f7       	brpl	.-8      	; 0x750c <DIO_InitPin+0x82>
    7514:	cb 01       	movw	r24, r22
    7516:	84 2b       	or	r24, r20
    7518:	81 bb       	out	0x11, r24	; 17
    751a:	08 95       	ret
    751c:	91 30       	cpi	r25, 0x01	; 1
    751e:	c1 f0       	breq	.+48     	; 0x7550 <DIO_InitPin+0xc6>
    7520:	28 f0       	brcs	.+10     	; 0x752c <DIO_InitPin+0xa2>
    7522:	92 30       	cpi	r25, 0x02	; 2
    7524:	39 f1       	breq	.+78     	; 0x7574 <DIO_InitPin+0xea>
    7526:	93 30       	cpi	r25, 0x03	; 3
    7528:	b9 f1       	breq	.+110    	; 0x7598 <DIO_InitPin+0x10e>
    752a:	08 95       	ret
    752c:	4a b3       	in	r20, 0x1a	; 26
    752e:	21 e0       	ldi	r18, 0x01	; 1
    7530:	30 e0       	ldi	r19, 0x00	; 0
    7532:	b9 01       	movw	r22, r18
    7534:	02 c0       	rjmp	.+4      	; 0x753a <DIO_InitPin+0xb0>
    7536:	66 0f       	add	r22, r22
    7538:	77 1f       	adc	r23, r23
    753a:	8a 95       	dec	r24
    753c:	e2 f7       	brpl	.-8      	; 0x7536 <DIO_InitPin+0xac>
    753e:	cb 01       	movw	r24, r22
    7540:	80 95       	com	r24
    7542:	94 2f       	mov	r25, r20
    7544:	98 23       	and	r25, r24
    7546:	9a bb       	out	0x1a, r25	; 26
    7548:	9b b3       	in	r25, 0x1b	; 27
    754a:	89 23       	and	r24, r25
    754c:	8b bb       	out	0x1b, r24	; 27
    754e:	08 95       	ret
    7550:	47 b3       	in	r20, 0x17	; 23
    7552:	21 e0       	ldi	r18, 0x01	; 1
    7554:	30 e0       	ldi	r19, 0x00	; 0
    7556:	b9 01       	movw	r22, r18
    7558:	02 c0       	rjmp	.+4      	; 0x755e <DIO_InitPin+0xd4>
    755a:	66 0f       	add	r22, r22
    755c:	77 1f       	adc	r23, r23
    755e:	8a 95       	dec	r24
    7560:	e2 f7       	brpl	.-8      	; 0x755a <DIO_InitPin+0xd0>
    7562:	cb 01       	movw	r24, r22
    7564:	80 95       	com	r24
    7566:	94 2f       	mov	r25, r20
    7568:	98 23       	and	r25, r24
    756a:	97 bb       	out	0x17, r25	; 23
    756c:	98 b3       	in	r25, 0x18	; 24
    756e:	89 23       	and	r24, r25
    7570:	88 bb       	out	0x18, r24	; 24
    7572:	08 95       	ret
    7574:	44 b3       	in	r20, 0x14	; 20
    7576:	21 e0       	ldi	r18, 0x01	; 1
    7578:	30 e0       	ldi	r19, 0x00	; 0
    757a:	b9 01       	movw	r22, r18
    757c:	02 c0       	rjmp	.+4      	; 0x7582 <DIO_InitPin+0xf8>
    757e:	66 0f       	add	r22, r22
    7580:	77 1f       	adc	r23, r23
    7582:	8a 95       	dec	r24
    7584:	e2 f7       	brpl	.-8      	; 0x757e <DIO_InitPin+0xf4>
    7586:	cb 01       	movw	r24, r22
    7588:	80 95       	com	r24
    758a:	94 2f       	mov	r25, r20
    758c:	98 23       	and	r25, r24
    758e:	94 bb       	out	0x14, r25	; 20
    7590:	95 b3       	in	r25, 0x15	; 21
    7592:	89 23       	and	r24, r25
    7594:	85 bb       	out	0x15, r24	; 21
    7596:	08 95       	ret
    7598:	41 b3       	in	r20, 0x11	; 17
    759a:	21 e0       	ldi	r18, 0x01	; 1
    759c:	30 e0       	ldi	r19, 0x00	; 0
    759e:	b9 01       	movw	r22, r18
    75a0:	02 c0       	rjmp	.+4      	; 0x75a6 <DIO_InitPin+0x11c>
    75a2:	66 0f       	add	r22, r22
    75a4:	77 1f       	adc	r23, r23
    75a6:	8a 95       	dec	r24
    75a8:	e2 f7       	brpl	.-8      	; 0x75a2 <DIO_InitPin+0x118>
    75aa:	cb 01       	movw	r24, r22
    75ac:	80 95       	com	r24
    75ae:	94 2f       	mov	r25, r20
    75b0:	98 23       	and	r25, r24
    75b2:	91 bb       	out	0x11, r25	; 17
    75b4:	92 b3       	in	r25, 0x12	; 18
    75b6:	89 23       	and	r24, r25
    75b8:	82 bb       	out	0x12, r24	; 18
    75ba:	08 95       	ret
    75bc:	91 30       	cpi	r25, 0x01	; 1
    75be:	c1 f0       	breq	.+48     	; 0x75f0 <DIO_InitPin+0x166>
    75c0:	28 f0       	brcs	.+10     	; 0x75cc <DIO_InitPin+0x142>
    75c2:	92 30       	cpi	r25, 0x02	; 2
    75c4:	39 f1       	breq	.+78     	; 0x7614 <DIO_InitPin+0x18a>
    75c6:	93 30       	cpi	r25, 0x03	; 3
    75c8:	b9 f1       	breq	.+110    	; 0x7638 <DIO_InitPin+0x1ae>
    75ca:	08 95       	ret
    75cc:	4a b3       	in	r20, 0x1a	; 26
    75ce:	21 e0       	ldi	r18, 0x01	; 1
    75d0:	30 e0       	ldi	r19, 0x00	; 0
    75d2:	b9 01       	movw	r22, r18
    75d4:	02 c0       	rjmp	.+4      	; 0x75da <DIO_InitPin+0x150>
    75d6:	66 0f       	add	r22, r22
    75d8:	77 1f       	adc	r23, r23
    75da:	8a 95       	dec	r24
    75dc:	e2 f7       	brpl	.-8      	; 0x75d6 <DIO_InitPin+0x14c>
    75de:	cb 01       	movw	r24, r22
    75e0:	96 2f       	mov	r25, r22
    75e2:	90 95       	com	r25
    75e4:	94 23       	and	r25, r20
    75e6:	9a bb       	out	0x1a, r25	; 26
    75e8:	9b b3       	in	r25, 0x1b	; 27
    75ea:	89 2b       	or	r24, r25
    75ec:	8b bb       	out	0x1b, r24	; 27
    75ee:	08 95       	ret
    75f0:	47 b3       	in	r20, 0x17	; 23
    75f2:	21 e0       	ldi	r18, 0x01	; 1
    75f4:	30 e0       	ldi	r19, 0x00	; 0
    75f6:	b9 01       	movw	r22, r18
    75f8:	02 c0       	rjmp	.+4      	; 0x75fe <DIO_InitPin+0x174>
    75fa:	66 0f       	add	r22, r22
    75fc:	77 1f       	adc	r23, r23
    75fe:	8a 95       	dec	r24
    7600:	e2 f7       	brpl	.-8      	; 0x75fa <DIO_InitPin+0x170>
    7602:	cb 01       	movw	r24, r22
    7604:	96 2f       	mov	r25, r22
    7606:	90 95       	com	r25
    7608:	94 23       	and	r25, r20
    760a:	97 bb       	out	0x17, r25	; 23
    760c:	98 b3       	in	r25, 0x18	; 24
    760e:	89 2b       	or	r24, r25
    7610:	88 bb       	out	0x18, r24	; 24
    7612:	08 95       	ret
    7614:	44 b3       	in	r20, 0x14	; 20
    7616:	21 e0       	ldi	r18, 0x01	; 1
    7618:	30 e0       	ldi	r19, 0x00	; 0
    761a:	b9 01       	movw	r22, r18
    761c:	02 c0       	rjmp	.+4      	; 0x7622 <DIO_InitPin+0x198>
    761e:	66 0f       	add	r22, r22
    7620:	77 1f       	adc	r23, r23
    7622:	8a 95       	dec	r24
    7624:	e2 f7       	brpl	.-8      	; 0x761e <DIO_InitPin+0x194>
    7626:	cb 01       	movw	r24, r22
    7628:	96 2f       	mov	r25, r22
    762a:	90 95       	com	r25
    762c:	94 23       	and	r25, r20
    762e:	94 bb       	out	0x14, r25	; 20
    7630:	95 b3       	in	r25, 0x15	; 21
    7632:	89 2b       	or	r24, r25
    7634:	85 bb       	out	0x15, r24	; 21
    7636:	08 95       	ret
    7638:	41 b3       	in	r20, 0x11	; 17
    763a:	21 e0       	ldi	r18, 0x01	; 1
    763c:	30 e0       	ldi	r19, 0x00	; 0
    763e:	b9 01       	movw	r22, r18
    7640:	02 c0       	rjmp	.+4      	; 0x7646 <DIO_InitPin+0x1bc>
    7642:	66 0f       	add	r22, r22
    7644:	77 1f       	adc	r23, r23
    7646:	8a 95       	dec	r24
    7648:	e2 f7       	brpl	.-8      	; 0x7642 <DIO_InitPin+0x1b8>
    764a:	cb 01       	movw	r24, r22
    764c:	96 2f       	mov	r25, r22
    764e:	90 95       	com	r25
    7650:	94 23       	and	r25, r20
    7652:	91 bb       	out	0x11, r25	; 17
    7654:	92 b3       	in	r25, 0x12	; 18
    7656:	89 2b       	or	r24, r25
    7658:	82 bb       	out	0x12, r24	; 18
    765a:	08 95       	ret

0000765c <DIO_Init>:
    765c:	cf 93       	push	r28
    765e:	c0 e0       	ldi	r28, 0x00	; 0
    7660:	09 c0       	rjmp	.+18     	; 0x7674 <DIO_Init+0x18>
    7662:	ec 2f       	mov	r30, r28
    7664:	f0 e0       	ldi	r31, 0x00	; 0
    7666:	e0 5a       	subi	r30, 0xA0	; 160
    7668:	ff 4f       	sbci	r31, 0xFF	; 255
    766a:	60 81       	ld	r22, Z
    766c:	8c 2f       	mov	r24, r28
    766e:	0e 94 45 3a 	call	0x748a	; 0x748a <DIO_InitPin>
    7672:	cf 5f       	subi	r28, 0xFF	; 255
    7674:	c0 32       	cpi	r28, 0x20	; 32
    7676:	a8 f3       	brcs	.-22     	; 0x7662 <DIO_Init+0x6>
    7678:	cf 91       	pop	r28
    767a:	08 95       	ret

0000767c <DIO_WritePin>:

void DIO_WritePin(DIO_Pin_type pin,DIO_Voltage_type volt)
{
	DIO_Port_type port;
	DIO_PortPin_t pin_num;
	port=pin/8;
    767c:	98 2f       	mov	r25, r24
    767e:	96 95       	lsr	r25
    7680:	96 95       	lsr	r25
    7682:	96 95       	lsr	r25
	pin_num=pin%8;
    7684:	87 70       	andi	r24, 0x07	; 7
	switch(port)
    7686:	91 30       	cpi	r25, 0x01	; 1
    7688:	41 f1       	breq	.+80     	; 0x76da <DIO_WritePin+0x5e>
    768a:	38 f0       	brcs	.+14     	; 0x769a <DIO_WritePin+0x1e>
    768c:	92 30       	cpi	r25, 0x02	; 2
    768e:	09 f4       	brne	.+2      	; 0x7692 <DIO_WritePin+0x16>
    7690:	44 c0       	rjmp	.+136    	; 0x771a <DIO_WritePin+0x9e>
    7692:	93 30       	cpi	r25, 0x03	; 3
    7694:	09 f4       	brne	.+2      	; 0x7698 <DIO_WritePin+0x1c>
    7696:	60 c0       	rjmp	.+192    	; 0x7758 <DIO_WritePin+0xdc>
    7698:	08 95       	ret
	{
		case PA:
		switch(volt)
    769a:	66 23       	and	r22, r22
    769c:	81 f0       	breq	.+32     	; 0x76be <DIO_WritePin+0x42>
    769e:	61 30       	cpi	r22, 0x01	; 1
    76a0:	09 f0       	breq	.+2      	; 0x76a4 <DIO_WritePin+0x28>
    76a2:	78 c0       	rjmp	.+240    	; 0x7794 <DIO_WritePin+0x118>
		{
			case HIGH:
			SET_BIT(PORTA,pin_num);
    76a4:	4b b3       	in	r20, 0x1b	; 27
    76a6:	21 e0       	ldi	r18, 0x01	; 1
    76a8:	30 e0       	ldi	r19, 0x00	; 0
    76aa:	b9 01       	movw	r22, r18
    76ac:	02 c0       	rjmp	.+4      	; 0x76b2 <DIO_WritePin+0x36>
    76ae:	66 0f       	add	r22, r22
    76b0:	77 1f       	adc	r23, r23
    76b2:	8a 95       	dec	r24
    76b4:	e2 f7       	brpl	.-8      	; 0x76ae <DIO_WritePin+0x32>
    76b6:	cb 01       	movw	r24, r22
    76b8:	84 2b       	or	r24, r20
    76ba:	8b bb       	out	0x1b, r24	; 27
			break;
    76bc:	08 95       	ret
			case LOW:
			CLR_BIT(PORTA,pin_num);
    76be:	4b b3       	in	r20, 0x1b	; 27
    76c0:	21 e0       	ldi	r18, 0x01	; 1
    76c2:	30 e0       	ldi	r19, 0x00	; 0
    76c4:	b9 01       	movw	r22, r18
    76c6:	02 c0       	rjmp	.+4      	; 0x76cc <DIO_WritePin+0x50>
    76c8:	66 0f       	add	r22, r22
    76ca:	77 1f       	adc	r23, r23
    76cc:	8a 95       	dec	r24
    76ce:	e2 f7       	brpl	.-8      	; 0x76c8 <DIO_WritePin+0x4c>
    76d0:	cb 01       	movw	r24, r22
    76d2:	80 95       	com	r24
    76d4:	84 23       	and	r24, r20
    76d6:	8b bb       	out	0x1b, r24	; 27
			break;
    76d8:	08 95       	ret
		}
		break;
		case PB:
		switch(volt)
    76da:	66 23       	and	r22, r22
    76dc:	81 f0       	breq	.+32     	; 0x76fe <DIO_WritePin+0x82>
    76de:	61 30       	cpi	r22, 0x01	; 1
    76e0:	09 f0       	breq	.+2      	; 0x76e4 <DIO_WritePin+0x68>
    76e2:	58 c0       	rjmp	.+176    	; 0x7794 <DIO_WritePin+0x118>
		{
			case HIGH:
			SET_BIT(PORTB,pin_num);
    76e4:	48 b3       	in	r20, 0x18	; 24
    76e6:	21 e0       	ldi	r18, 0x01	; 1
    76e8:	30 e0       	ldi	r19, 0x00	; 0
    76ea:	b9 01       	movw	r22, r18
    76ec:	02 c0       	rjmp	.+4      	; 0x76f2 <DIO_WritePin+0x76>
    76ee:	66 0f       	add	r22, r22
    76f0:	77 1f       	adc	r23, r23
    76f2:	8a 95       	dec	r24
    76f4:	e2 f7       	brpl	.-8      	; 0x76ee <DIO_WritePin+0x72>
    76f6:	cb 01       	movw	r24, r22
    76f8:	84 2b       	or	r24, r20
    76fa:	88 bb       	out	0x18, r24	; 24
			break;
    76fc:	08 95       	ret
			case LOW:
			CLR_BIT(PORTB,pin_num);
    76fe:	48 b3       	in	r20, 0x18	; 24
    7700:	21 e0       	ldi	r18, 0x01	; 1
    7702:	30 e0       	ldi	r19, 0x00	; 0
    7704:	b9 01       	movw	r22, r18
    7706:	02 c0       	rjmp	.+4      	; 0x770c <DIO_WritePin+0x90>
    7708:	66 0f       	add	r22, r22
    770a:	77 1f       	adc	r23, r23
    770c:	8a 95       	dec	r24
    770e:	e2 f7       	brpl	.-8      	; 0x7708 <DIO_WritePin+0x8c>
    7710:	cb 01       	movw	r24, r22
    7712:	80 95       	com	r24
    7714:	84 23       	and	r24, r20
    7716:	88 bb       	out	0x18, r24	; 24
			break;
    7718:	08 95       	ret
		}
		break;
		case PC:
		switch(volt)
    771a:	66 23       	and	r22, r22
    771c:	79 f0       	breq	.+30     	; 0x773c <DIO_WritePin+0xc0>
    771e:	61 30       	cpi	r22, 0x01	; 1
    7720:	c9 f5       	brne	.+114    	; 0x7794 <DIO_WritePin+0x118>
		{
			case HIGH:
			SET_BIT(PORTC,pin_num);
    7722:	45 b3       	in	r20, 0x15	; 21
    7724:	21 e0       	ldi	r18, 0x01	; 1
    7726:	30 e0       	ldi	r19, 0x00	; 0
    7728:	b9 01       	movw	r22, r18
    772a:	02 c0       	rjmp	.+4      	; 0x7730 <DIO_WritePin+0xb4>
    772c:	66 0f       	add	r22, r22
    772e:	77 1f       	adc	r23, r23
    7730:	8a 95       	dec	r24
    7732:	e2 f7       	brpl	.-8      	; 0x772c <DIO_WritePin+0xb0>
    7734:	cb 01       	movw	r24, r22
    7736:	84 2b       	or	r24, r20
    7738:	85 bb       	out	0x15, r24	; 21
			break;
    773a:	08 95       	ret
			case LOW:
			CLR_BIT(PORTC,pin_num);
    773c:	45 b3       	in	r20, 0x15	; 21
    773e:	21 e0       	ldi	r18, 0x01	; 1
    7740:	30 e0       	ldi	r19, 0x00	; 0
    7742:	b9 01       	movw	r22, r18
    7744:	02 c0       	rjmp	.+4      	; 0x774a <DIO_WritePin+0xce>
    7746:	66 0f       	add	r22, r22
    7748:	77 1f       	adc	r23, r23
    774a:	8a 95       	dec	r24
    774c:	e2 f7       	brpl	.-8      	; 0x7746 <DIO_WritePin+0xca>
    774e:	cb 01       	movw	r24, r22
    7750:	80 95       	com	r24
    7752:	84 23       	and	r24, r20
    7754:	85 bb       	out	0x15, r24	; 21
			break;
    7756:	08 95       	ret
		}
		break;
		case PD:
		switch(volt)
    7758:	66 23       	and	r22, r22
    775a:	79 f0       	breq	.+30     	; 0x777a <DIO_WritePin+0xfe>
    775c:	61 30       	cpi	r22, 0x01	; 1
    775e:	d1 f4       	brne	.+52     	; 0x7794 <DIO_WritePin+0x118>
		{
			case HIGH:
			SET_BIT(PORTD,pin_num);
    7760:	42 b3       	in	r20, 0x12	; 18
    7762:	21 e0       	ldi	r18, 0x01	; 1
    7764:	30 e0       	ldi	r19, 0x00	; 0
    7766:	b9 01       	movw	r22, r18
    7768:	02 c0       	rjmp	.+4      	; 0x776e <DIO_WritePin+0xf2>
    776a:	66 0f       	add	r22, r22
    776c:	77 1f       	adc	r23, r23
    776e:	8a 95       	dec	r24
    7770:	e2 f7       	brpl	.-8      	; 0x776a <DIO_WritePin+0xee>
    7772:	cb 01       	movw	r24, r22
    7774:	84 2b       	or	r24, r20
    7776:	82 bb       	out	0x12, r24	; 18
			break;
    7778:	08 95       	ret
			case LOW:
			CLR_BIT(PORTD,pin_num);
    777a:	42 b3       	in	r20, 0x12	; 18
    777c:	21 e0       	ldi	r18, 0x01	; 1
    777e:	30 e0       	ldi	r19, 0x00	; 0
    7780:	b9 01       	movw	r22, r18
    7782:	02 c0       	rjmp	.+4      	; 0x7788 <DIO_WritePin+0x10c>
    7784:	66 0f       	add	r22, r22
    7786:	77 1f       	adc	r23, r23
    7788:	8a 95       	dec	r24
    778a:	e2 f7       	brpl	.-8      	; 0x7784 <DIO_WritePin+0x108>
    778c:	cb 01       	movw	r24, r22
    778e:	80 95       	com	r24
    7790:	84 23       	and	r24, r20
    7792:	82 bb       	out	0x12, r24	; 18
    7794:	08 95       	ret

00007796 <EEPROM_WriteData>:
#include "EEPROM.h"

void EEPROM_WriteData(u16 add,u8 data)
{
	/* Wait for completion of previous write */
	while(EECR & (1<<EEWE));
    7796:	e1 99       	sbic	0x1c, 1	; 28
    7798:	fe cf       	rjmp	.-4      	; 0x7796 <EEPROM_WriteData>
	/* Set up address and data registers */
	EEAR = add;
    779a:	9f bb       	out	0x1f, r25	; 31
    779c:	8e bb       	out	0x1e, r24	; 30
	EEDR = data;
    779e:	6d bb       	out	0x1d, r22	; 29
	/* Write logical one to EEMWE */
	EECR |= (1<<EEMWE);
    77a0:	8c b3       	in	r24, 0x1c	; 28
    77a2:	84 60       	ori	r24, 0x04	; 4
    77a4:	8c bb       	out	0x1c, r24	; 28
	/* Start eeprom write by setting EEWE */
	EECR |= (1<<EEWE);
    77a6:	8c b3       	in	r24, 0x1c	; 28
    77a8:	82 60       	ori	r24, 0x02	; 2
    77aa:	8c bb       	out	0x1c, r24	; 28
    77ac:	08 95       	ret

000077ae <EEPROM_ReadData>:
}

u8 EEPROM_ReadData(u16 add)
{
	/* Wait for completion of previous Read */
	while(EECR & (1<<EEWE));
    77ae:	e1 99       	sbic	0x1c, 1	; 28
    77b0:	fe cf       	rjmp	.-4      	; 0x77ae <EEPROM_ReadData>
	/* Set up address register */
	EEAR = add;
    77b2:	9f bb       	out	0x1f, r25	; 31
    77b4:	8e bb       	out	0x1e, r24	; 30
	/* Start eeprom read by writing EERE */
	EECR |= (1<<EERE);
    77b6:	8c b3       	in	r24, 0x1c	; 28
    77b8:	81 60       	ori	r24, 0x01	; 1
    77ba:	8c bb       	out	0x1c, r24	; 28
	/* Return data from data register */
	return EEDR;
    77bc:	8d b3       	in	r24, 0x1d	; 29
    77be:	08 95       	ret

000077c0 <UART_Init>:
{
	Rx_Ptr=pfn;
}
void UART_TX_SetCallBack(void(*pfn)(void))
{
	Tx_Ptr=pfn;
    77c0:	8b b1       	in	r24, 0x0b	; 11
    77c2:	8d 7f       	andi	r24, 0xFD	; 253
    77c4:	8b b9       	out	0x0b, r24	; 11
    77c6:	83 e3       	ldi	r24, 0x33	; 51
    77c8:	89 b9       	out	0x09, r24	; 9
    77ca:	8a b1       	in	r24, 0x0a	; 10
    77cc:	88 60       	ori	r24, 0x08	; 8
    77ce:	8a b9       	out	0x0a, r24	; 10
    77d0:	8a b1       	in	r24, 0x0a	; 10
    77d2:	80 61       	ori	r24, 0x10	; 16
    77d4:	8a b9       	out	0x0a, r24	; 10
    77d6:	08 95       	ret

000077d8 <UART_SendUsingPooling>:
    77d8:	5d 9b       	sbis	0x0b, 5	; 11
    77da:	fe cf       	rjmp	.-4      	; 0x77d8 <UART_SendUsingPooling>
    77dc:	8c b9       	out	0x0c, r24	; 12
    77de:	08 95       	ret

000077e0 <UART_ReceiveByteNoBlock>:
    77e0:	8c b1       	in	r24, 0x0c	; 12
    77e2:	08 95       	ret

000077e4 <UART_RX_InterruptEnable>:
    77e4:	8a b1       	in	r24, 0x0a	; 10
    77e6:	80 68       	ori	r24, 0x80	; 128
    77e8:	8a b9       	out	0x0a, r24	; 10
    77ea:	08 95       	ret

000077ec <UART_RX_SetCallBack>:
    77ec:	90 93 8e 00 	sts	0x008E, r25	; 0x80008e <Rx_Ptr+0x1>
    77f0:	80 93 8d 00 	sts	0x008D, r24	; 0x80008d <Rx_Ptr>
    77f4:	08 95       	ret

000077f6 <__vector_13>:
}

/* RX___Tx ISRs */

ISR(UART_RX_vect)
{
    77f6:	1f 92       	push	r1
    77f8:	0f 92       	push	r0
    77fa:	0f b6       	in	r0, 0x3f	; 63
    77fc:	0f 92       	push	r0
    77fe:	11 24       	eor	r1, r1
    7800:	2f 93       	push	r18
    7802:	3f 93       	push	r19
    7804:	4f 93       	push	r20
    7806:	5f 93       	push	r21
    7808:	6f 93       	push	r22
    780a:	7f 93       	push	r23
    780c:	8f 93       	push	r24
    780e:	9f 93       	push	r25
    7810:	af 93       	push	r26
    7812:	bf 93       	push	r27
    7814:	ef 93       	push	r30
    7816:	ff 93       	push	r31
	if(Rx_Ptr!=NULLPTR)
    7818:	e0 91 8d 00 	lds	r30, 0x008D	; 0x80008d <Rx_Ptr>
    781c:	f0 91 8e 00 	lds	r31, 0x008E	; 0x80008e <Rx_Ptr+0x1>
    7820:	30 97       	sbiw	r30, 0x00	; 0
    7822:	09 f0       	breq	.+2      	; 0x7826 <__vector_13+0x30>
	{
		Rx_Ptr();
    7824:	09 95       	icall
	}
	
}
    7826:	ff 91       	pop	r31
    7828:	ef 91       	pop	r30
    782a:	bf 91       	pop	r27
    782c:	af 91       	pop	r26
    782e:	9f 91       	pop	r25
    7830:	8f 91       	pop	r24
    7832:	7f 91       	pop	r23
    7834:	6f 91       	pop	r22
    7836:	5f 91       	pop	r21
    7838:	4f 91       	pop	r20
    783a:	3f 91       	pop	r19
    783c:	2f 91       	pop	r18
    783e:	0f 90       	pop	r0
    7840:	0f be       	out	0x3f, r0	; 63
    7842:	0f 90       	pop	r0
    7844:	1f 90       	pop	r1
    7846:	18 95       	reti

00007848 <__vector_15>:
ISR(UART_TX_vect)
{
    7848:	1f 92       	push	r1
    784a:	0f 92       	push	r0
    784c:	0f b6       	in	r0, 0x3f	; 63
    784e:	0f 92       	push	r0
    7850:	11 24       	eor	r1, r1
    7852:	2f 93       	push	r18
    7854:	3f 93       	push	r19
    7856:	4f 93       	push	r20
    7858:	5f 93       	push	r21
    785a:	6f 93       	push	r22
    785c:	7f 93       	push	r23
    785e:	8f 93       	push	r24
    7860:	9f 93       	push	r25
    7862:	af 93       	push	r26
    7864:	bf 93       	push	r27
    7866:	ef 93       	push	r30
    7868:	ff 93       	push	r31
	if(Tx_Ptr!=NULLPTR)
    786a:	e0 91 8f 00 	lds	r30, 0x008F	; 0x80008f <Tx_Ptr>
    786e:	f0 91 90 00 	lds	r31, 0x0090	; 0x800090 <Tx_Ptr+0x1>
    7872:	30 97       	sbiw	r30, 0x00	; 0
    7874:	09 f0       	breq	.+2      	; 0x7878 <__vector_15+0x30>
	{
		Tx_Ptr();
    7876:	09 95       	icall
	}
    7878:	ff 91       	pop	r31
    787a:	ef 91       	pop	r30
    787c:	bf 91       	pop	r27
    787e:	af 91       	pop	r26
    7880:	9f 91       	pop	r25
    7882:	8f 91       	pop	r24
    7884:	7f 91       	pop	r23
    7886:	6f 91       	pop	r22
    7888:	5f 91       	pop	r21
    788a:	4f 91       	pop	r20
    788c:	3f 91       	pop	r19
    788e:	2f 91       	pop	r18
    7890:	0f 90       	pop	r0
    7892:	0f be       	out	0x3f, r0	; 63
    7894:	0f 90       	pop	r0
    7896:	1f 90       	pop	r1
    7898:	18 95       	reti

0000789a <_exit>:
    789a:	f8 94       	cli

0000789c <__stop_program>:
    789c:	ff cf       	rjmp	.-2      	; 0x789c <__stop_program>
